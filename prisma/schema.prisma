// IRA Platform - Prisma Schema
// Better Auth + Application Models

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTHENTICATION (Better Auth Tables)
// ============================================

enum UserRole {
  ASSESSOR
  REVIEWER
}

model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Custom role field for IRA
  role          UserRole  @default(ASSESSOR)
  isActive      Boolean   @default(true)

  // Better Auth relations
  sessions      Session[]
  accounts      Account[]

  // Application relations
  assignedLeads    Lead[]       @relation("AssignedLeads")
  createdLeads     Lead[]       @relation("CreatedLeads")
  assessments      Assessment[] @relation("AssessorAssessments")
  uploadedDocs     Document[]   @relation("UploadedDocuments")
  auditLogs        AuditLog[]   @relation("UserAuditLogs")

  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  expiresAt             DateTime?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
  @@map("verification")
}

// ============================================
// APPLICATION MODELS
// ============================================

enum LeadStatus {
  NEW
  ASSIGNED
  IN_REVIEW
  PAYMENT_PENDING
  COMPLETED
}

enum AssessmentStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

enum QuestionType {
  ELIGIBILITY
  COMPANY
  FINANCIAL
  SECTOR
}

enum DocumentType {
  PDF
  JPG
  JPEG
  PNG
}

model Lead {
  id        String     @id @default(cuid())
  leadId    String     @unique // Display ID (LD-2024-001)

  // Company info
  companyName    String
  contactPerson  String
  phone          String
  email          String
  cin            String  @unique // Company Identification Number
  address        String  @db.Text

  // Probe42 Company Data
  probe42Fetched        Boolean   @default(false)
  probe42FetchedAt      DateTime?
  probe42LegalName      String?
  probe42Status         String?
  probe42Classification String?
  probe42PaidUpCapital  BigInt?
  probe42AuthCapital    BigInt?
  probe42Pan            String?
  probe42Website        String?
  probe42IncorpDate     DateTime?
  probe42ComplianceStatus String?
  probe42DirectorCount  Int?
  probe42GstCount       Int?
  probe42Data           Json?     // Full Probe42 response

  // Status & assignment
  status               LeadStatus  @default(NEW)
  assignedAssessorId   String?
  assignedAssessor     User?       @relation("AssignedLeads", fields: [assignedAssessorId], references: [id])

  // Relations
  assessment    Assessment?
  documents     Document[]
  auditLogs     AuditLog[]

  // Metadata
  createdById   String
  createdBy     User      @relation("CreatedLeads", fields: [createdById], references: [id])
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([status])
  @@index([assignedAssessorId])
  @@index([createdById])
  @@map("lead")
}

model Assessment {
  id        String   @id @default(cuid())
  leadId    String   @unique
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)

  assessorId String
  assessor   User    @relation("AssessorAssessments", fields: [assessorId], references: [id])

  // Question versioning (snapshot when assessment created)
  questionSnapshot         Json?     // Stores {eligibility: [...], company: [...], financial: [...], sector: [...]}
  questionSnapshotVersion  String?   // Hash/timestamp to detect changes
  usesOldQuestions         Boolean   @default(false) // True if submitted with outdated questions

  // Step 1: Eligibility (JSON: questionId -> {checked, remark})
  eligibilityAnswers      Json     @default("{}")
  isEligible              Boolean?
  eligibilityCompletedAt  DateTime?

  // Step 2: Main Questions (JSON: questionId -> {score, remark, evidenceLink})
  companyAnswers    Json  @default("{}")
  financialAnswers  Json  @default("{}")
  sectorAnswers     Json  @default("{}")

  // Probe42 integration
  probe42Fetched   Boolean   @default(false)
  probe42FetchedAt DateTime?
  probe42Data      Json?

  // Scoring
  totalScore  Int?
  percentage  Float?
  rating      String? // IPO_READY | NEEDS_IMPROVEMENT | NOT_READY

  // Workflow
  status             AssessmentStatus  @default(DRAFT)
  submittedAt        DateTime?
  reviewedAt         DateTime?
  reviewHistory      Json             @default("[]") // Array of {reviewedAt, action, comments}

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([assessorId])
  @@index([status])
  @@index([status, submittedAt])
  @@index([status, usesOldQuestions])
  @@index([leadId, status])
  @@index([assessorId, status]) // ✅ PERFORMANCE: Composite index for assessor's filtered queries
  @@map("assessment")
}

model Document {
  id         String       @id @default(cuid())
  leadId     String
  lead       Lead         @relation(fields: [leadId], references: [id], onDelete: Cascade)

  fileName   String
  fileUrl    String       @db.Text
  fileType   DocumentType
  fileSize   Int          // in bytes

  uploadedById String
  uploadedBy   User    @relation("UploadedDocuments", fields: [uploadedById], references: [id])
  uploadedAt   DateTime @default(now())

  @@index([leadId])
  @@index([uploadedById])
  @@map("document")
}

model Question {
  id        String       @id @default(cuid())
  type      QuestionType
  text      String       @db.Text
  order     Int
  helpText  String?      @db.Text
  isActive  Boolean      @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, order])
  @@index([type, isActive]) // ✅ PERFORMANCE: Composite index for filtered queries
  @@map("question")
}

model AuditLog {
  id        String   @id @default(cuid())

  leadId    String?
  lead      Lead?    @relation(fields: [leadId], references: [id], onDelete: Cascade)

  userId    String
  user      User     @relation("UserAuditLogs", fields: [userId], references: [id])

  action    String   // LEAD_CREATED, ASSIGNED, SUBMITTED, etc.
  details   Json?    // Additional context

  createdAt DateTime @default(now())

  @@index([leadId])
  @@index([userId])
  @@index([createdAt])
  @@map("audit_log")
}

// Counter for atomic sequence generation (prevents race conditions)
model Counter {
  id    String @id
  value Int    @default(0)

  @@map("counter")
}