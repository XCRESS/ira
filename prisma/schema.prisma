// IRA Platform - Prisma Schema
// Better Auth + Application Models

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTHENTICATION (Better Auth Tables)
// ============================================

enum UserRole {
  ASSESSOR
  REVIEWER
}

model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Custom role field for IRA
  role          UserRole  @default(ASSESSOR)
  isActive      Boolean   @default(true)

  // Better Auth relations
  sessions      Session[]
  accounts      Account[]

  // Application relations
  assignedLeads         Lead[]               @relation("AssignedLeads")
  createdLeads          Lead[]               @relation("CreatedLeads")
  assessments           Assessment[]         @relation("AssessorAssessments")
  uploadedDocs          Document[]           @relation("UploadedDocuments")
  auditLogs             AuditLog[]           @relation("UserAuditLogs")
  convertedSubmissions  OrganicSubmission[]  @relation("ConvertedSubmissions")
  rejectedSubmissions   OrganicSubmission[]  @relation("RejectedSubmissions")

  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  expiresAt             DateTime?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
  @@map("verification")
}

// ============================================
// APPLICATION MODELS
// ============================================

enum LeadStatus {
  NEW
  ASSIGNED
  IN_REVIEW
  PAYMENT_PENDING
  COMPLETED
}

enum AssessmentStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

enum QuestionType {
  ELIGIBILITY
  COMPANY
  FINANCIAL
  SECTOR
}

enum DocumentType {
  PDF
  JPG
  JPEG
  PNG
}

enum OrganicSubmissionStatus {
  PENDING
  CONVERTED
  REJECTED
}

model Lead {
  id        String     @id @default(cuid())
  leadId    String     @unique // Display ID (LD-2024-001)

  // Company info
  companyName    String
  contactPerson  String
  phone          String? // Optional - may not be available for organic submissions
  email          String
  cin            String  @unique // Company Identification Number
  address        String  @db.Text

  // Probe42 Company Data
  probe42Fetched        Boolean   @default(false)
  probe42FetchedAt      DateTime?
  probe42LegalName      String?
  probe42Status         String?
  probe42Classification String?
  probe42PaidUpCapital  BigInt?
  probe42AuthCapital    BigInt?
  probe42Pan            String?
  probe42Website        String?
  probe42IncorpDate     DateTime?
  probe42ComplianceStatus String?
  probe42DirectorCount  Int?
  probe42GstCount       Int?
  probe42Data           Json?     // Full Probe42 response

  // Probe42 Report Download Status
  probe42ReportDownloaded  Boolean   @default(false)
  probe42ReportDownloadedAt DateTime?
  probe42ReportFailedAt    DateTime?

  // Status & assignment
  status               LeadStatus  @default(NEW)
  assignedAssessorId   String?
  assignedAssessor     User?       @relation("AssignedLeads", fields: [assignedAssessorId], references: [id])

  // Relations
  assessment          Assessment?
  documents           Document[]
  auditLogs           AuditLog[]
  organicSubmissions  OrganicSubmission[]  // Reverse relation

  // Metadata
  createdById   String
  createdBy     User      @relation("CreatedLeads", fields: [createdById], references: [id])
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([status])
  @@index([assignedAssessorId])
  @@index([createdById])
  @@index([leadId]) // ✅ PERFORMANCE: Index for search-by-display-ID queries
  @@map("lead")
}

model Assessment {
  id        String   @id @default(cuid())
  leadId    String   @unique
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)

  assessorId String
  assessor   User    @relation("AssessorAssessments", fields: [assessorId], references: [id])

  // Current step in stepper (1, 2, or 3)
  currentStep  Int  @default(1)

  // ==========================================
  // STEP 1: Company Verification
  // ==========================================
  // Assessor verifies company data from Probe42
  companyVerified       Boolean   @default(false)
  companyVerifiedAt     DateTime?
  companyDataSnapshot   Json?     // Snapshot of verified company data {name, address, pan, gst}

  // ==========================================
  // STEP 2: Financial Data Verification
  // ==========================================
  // Assessor confirms financial data from Probe42
  financialVerified     Boolean   @default(false)
  financialVerifiedAt   DateTime?
  financialDataSnapshot Json?     // Snapshot of financial data {paidUpCapital, shares, netWorth, etc.}

  // ==========================================
  // STEP 3: Preset Questionnaire
  // ==========================================
  // Q1: Investment Plan Ready (Yes/No)
  hasInvestmentPlan  Boolean?

  // Q2: Corporate Governance (4 sub-questions)
  q2aGovernancePlan       Boolean?  // Governance meets listing norms
  q2bFinancialReporting   Boolean?  // Complies with statutory laws
  q2cControlSystems       Boolean?  // Robust control systems
  q2dShareholdingClear    Boolean?  // Clear shareholding

  // Q3: Right Team (4 sub-questions)
  q3aSeniorManagement     Boolean?  // Professional senior mgmt
  q3bIndependentBoard     Boolean?  // Credible independent directors
  q3cMidManagement        Boolean?  // Experienced mid-mgmt
  q3dKeyPersonnel         Boolean?  // Key personnel recognized

  // Q4-Q11: Financial Data (assessor inputs)
  q4PaidUpCapital        Float?    // In crores
  q5OutstandingShares    Int?      // Number of shares
  q6NetWorth             Float?    // In crores
  q7Borrowings           Float?    // Short + Long term in crores
  q8DebtEquityRatio      Float?    // Ratio value
  q9TurnoverYear1        Float?    // Turnover last 3 years (crores)
  q9TurnoverYear2        Float?
  q9TurnoverYear3        Float?
  q10EbitdaYear1         Float?    // EBITDA last 3 years (crores)
  q10EbitdaYear2         Float?
  q10EbitdaYear3         Float?
  q11Eps                 Float?    // Earnings per share

  // ==========================================
  // Scoring (Auto-calculated on submit)
  // ==========================================
  scoreBreakdown  Json?     // {q1: 10, q2: 4, q3: 4, q4: 5, ...}
  totalScore      Float?    // Total calculated score
  maxScore        Float?    // Maximum possible score
  percentage      Float?    // (totalScore / maxScore) * 100
  rating          String?   // IPO_READY | NEEDS_IMPROVEMENT | NOT_READY

  // ==========================================
  // Probe42 Integration
  // ==========================================
  probe42Fetched   Boolean   @default(false)
  probe42FetchedAt DateTime?
  probe42Data      Json?     // Full Probe42 API response

  // ==========================================
  // Workflow
  // ==========================================
  status             AssessmentStatus  @default(DRAFT)
  submittedAt        DateTime?
  reviewedAt         DateTime?
  reviewHistory      Json             @default("[]") // [{reviewedAt, action, comments, reviewerId}]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([assessorId])
  @@index([status])
  @@index([status, submittedAt])
  @@index([currentStep])
  @@index([leadId, status])
  @@index([assessorId, status])
  @@map("assessment")
}

model Document {
  id         String       @id @default(cuid())
  leadId     String
  lead       Lead         @relation(fields: [leadId], references: [id], onDelete: Cascade)

  fileName   String
  fileUrl    String       @db.Text
  fileType   DocumentType
  fileSize   Int          // in bytes

  uploadedById String
  uploadedBy   User    @relation("UploadedDocuments", fields: [uploadedById], references: [id])
  uploadedAt   DateTime @default(now())

  @@index([leadId])
  @@index([uploadedById])
  @@map("document")
}

model Question {
  id        String       @id @default(cuid())
  type      QuestionType
  text      String       @db.Text
  order     Int
  helpText  String?      @db.Text
  isActive  Boolean      @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, order])
  @@index([type, isActive]) // ✅ PERFORMANCE: Composite index for filtered queries
  @@map("question")
}

model AuditLog {
  id        String   @id @default(cuid())

  leadId    String?
  lead      Lead?    @relation(fields: [leadId], references: [id], onDelete: Cascade)

  userId    String
  user      User     @relation("UserAuditLogs", fields: [userId], references: [id])

  action    String   // LEAD_CREATED, ASSIGNED, SUBMITTED, etc.
  details   Json?    // Additional context

  createdAt DateTime @default(now())

  @@index([leadId])
  @@index([userId])
  @@index([createdAt])
  @@map("audit_log")
}

// Counter for atomic sequence generation (prevents race conditions)
model Counter {
  id    String @id
  value Int    @default(0)

  @@map("counter")
}

// Organic lead submissions from website (pre-lead stage)
model OrganicSubmission {
  id              String   @id @default(cuid())

  // Submitted information
  cin             String
  companyName     String
  contactPerson   String
  email           String
  phone           String?

  // Email verification (happens at submission, before lead creation)
  isEmailVerified          Boolean   @default(false)
  emailVerificationToken   String?   @unique
  emailVerificationExpiry  DateTime?
  emailVerifiedAt          DateTime?

  // Status tracking
  status          OrganicSubmissionStatus  @default(PENDING)

  // If converted to lead
  convertedToLeadId  String?
  convertedToLead    Lead?    @relation(fields: [convertedToLeadId], references: [id])
  convertedById      String?
  convertedBy        User?    @relation("ConvertedSubmissions", fields: [convertedById], references: [id])
  convertedAt        DateTime?

  // If rejected
  rejectedById    String?
  rejectedBy      User?    @relation("RejectedSubmissions", fields: [rejectedById], references: [id])
  rejectedAt      DateTime?
  rejectionReason String?  @db.Text

  // Metadata
  submittedAt     DateTime @default(now())

  @@unique([cin])
  @@index([status])
  @@index([submittedAt])
  @@index([isEmailVerified])
  @@map("organic_submission")
}